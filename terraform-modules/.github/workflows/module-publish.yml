name: OpenTofu Module Publishing

on:
  push:
    branches: [ main ]
    tags:
      - '*-v*'
  workflow_dispatch:
    inputs:
      module_name:
        description: 'Module to publish'
        required: true
        type: choice
        options:
        - ecr
        - fargate-service
        - iam
        - monitoring
        - networking
      version_bump:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

env:
  TOFU_VERSION: "1.6.0"

jobs:
  validate-before-publish:
    name: Validate Before Publishing
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup OpenTofu
      uses: opentofu/setup-opentofu@v1
      with:
        tofu_version: ${{ env.TOFU_VERSION }}
        
    - name: Run comprehensive module validation
      run: |
        # Validate all modules before publishing
        for module_dir in terraform-modules/*/; do
          if [ -d "$module_dir" ] && [ "$(basename "$module_dir")" != "tests" ]; then
            module_name=$(basename "$module_dir")
            echo "Validating $module_name..."
            
            cd "$module_dir"
            tofu init -backend=false
            tofu validate
            tofu fmt -check=true
            cd - > /dev/null
          fi
        done
        
    - name: Run security scans
      uses: bridgecrewio/checkov-action@master
      with:
        directory: terraform-modules/
        framework: terraform
        quiet: true
        soft_fail: false

  determine-modules:
    name: Determine Modules to Publish
    runs-on: ubuntu-latest
    outputs:
      modules: ${{ steps.modules.outputs.modules }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Determine modules to publish
      id: modules
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "modules=${{ github.event.inputs.module_name }}" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == refs/tags/*-v* ]]; then
          # Extract module name from tag
          tag_name=$(echo "${{ github.ref }}" | sed 's/refs\/tags\///')
          module_name=$(echo "$tag_name" | sed 's/-v.*//')
          echo "modules=$module_name" >> $GITHUB_OUTPUT
        else
          # Auto-detect changed modules
          changed_modules=""
          
          for module_dir in terraform-modules/*/; do
            if [ -d "$module_dir" ] && [ "$(basename "$module_dir")" != "tests" ]; then
              module_name=$(basename "$module_dir")
              
              # Check if module has changes since last tag
              if git diff --name-only HEAD~1 HEAD | grep -q "^terraform-modules/$module_name/"; then
                if [ -n "$changed_modules" ]; then
                  changed_modules="$changed_modules,$module_name"
                else
                  changed_modules="$module_name"
                fi
              fi
            fi
          done
          
          echo "modules=$changed_modules" >> $GITHUB_OUTPUT
        fi

  publish-modules:
    name: Publish Modules
    runs-on: ubuntu-latest
    needs: [validate-before-publish, determine-modules]
    if: needs.determine-modules.outputs.modules != ''
    
    strategy:
      matrix:
        module: ${{ fromJson(format('["{0}"]', needs.determine-modules.outputs.modules)) }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Setup OpenTofu
      uses: opentofu/setup-opentofu@v1
      with:
        tofu_version: ${{ env.TOFU_VERSION }}
        
    - name: Determine new version
      id: version
      run: |
        module_name="${{ matrix.module }}"
        
        # Get latest version tag for this module
        latest_tag=$(git tag -l "${module_name}-v*" | sort -V | tail -n1)
        
        if [ -z "$latest_tag" ]; then
          current_version="0.1.0"
        else
          current_version=$(echo "$latest_tag" | sed "s/${module_name}-v//")
        fi
        
        echo "current_version=$current_version" >> $GITHUB_OUTPUT
        
        # Determine version bump
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          bump_type="${{ github.event.inputs.version_bump }}"
        else
          bump_type="patch"  # Default for automatic publishing
        fi
        
        # Calculate new version
        IFS='.' read -ra VERSION_PARTS <<< "$current_version"
        major=${VERSION_PARTS[0]}
        minor=${VERSION_PARTS[1]}
        patch=${VERSION_PARTS[2]}
        
        case "$bump_type" in
          "major")
            major=$((major + 1))
            minor=0
            patch=0
            ;;
          "minor")
            minor=$((minor + 1))
            patch=0
            ;;
          "patch")
            patch=$((patch + 1))
            ;;
        esac
        
        new_version="$major.$minor.$patch"
        echo "new_version=$new_version" >> $GITHUB_OUTPUT
        echo "new_tag=${module_name}-v${new_version}" >> $GITHUB_OUTPUT
        
        echo "Bumping $module_name from $current_version to $new_version"
        
    - name: Create module archive
      run: |
        module_name="${{ matrix.module }}"
        version="${{ steps.version.outputs.new_version }}"
        
        mkdir -p dist/modules
        
        # Create archive
        tar -czf "dist/modules/${module_name}-${version}.tar.gz" \
          --exclude=".git*" \
          --exclude="*.log" \
          --exclude=".terraform*" \
          -C terraform-modules "$module_name"
        
        # Create module metadata
        cat > "dist/modules/${module_name}-${version}.json" << EOF
        {
          "name": "$module_name",
          "version": "$version",
          "archive": "${module_name}-${version}.tar.gz",
          "published_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "git_commit": "${{ github.sha }}",
          "git_ref": "${{ github.ref }}",
          "tofu_version": "${{ env.TOFU_VERSION }}"
        }
        EOF
        
        # Generate module documentation
        cd terraform-modules/$module_name
        
        # Extract variables documentation
        echo "## Variables" > variables.md
        echo "" >> variables.md
        echo "| Name | Description | Type | Default | Required |" >> variables.md
        echo "|------|-------------|------|---------|:--------:|" >> variables.md
        
        # Parse variables.tf for documentation
        if [ -f "variables.tf" ]; then
          awk '
          /^variable/ {
            var_name = $2
            gsub(/["]/, "", var_name)
            description = ""
            type = ""
            default = ""
            required = "yes"
          }
          /description.*=/ {
            gsub(/.*description.*=.*"/, "", $0)
            gsub(/".*/, "", $0)
            description = $0
          }
          /type.*=/ {
            gsub(/.*type.*=.*/, "", $0)
            gsub(/^[ \t]*/, "", $0)
            type = $0
          }
          /default.*=/ {
            required = "no"
            gsub(/.*default.*=.*/, "", $0)
            gsub(/^[ \t]*/, "", $0)
            default = $0
          }
          /^}/ && var_name {
            printf "| %s | %s | %s | %s | %s |\n", var_name, description, type, default, required
            var_name = ""
          }
          ' variables.tf >> variables.md
        fi
        
        # Extract outputs documentation
        echo "" >> variables.md
        echo "## Outputs" >> variables.md
        echo "" >> variables.md
        echo "| Name | Description |" >> variables.md
        echo "|------|-------------|" >> variables.md
        
        if [ -f "outputs.tf" ]; then
          awk '
          /^output/ {
            output_name = $2
            gsub(/["]/, "", output_name)
            description = ""
          }
          /description.*=/ {
            gsub(/.*description.*=.*"/, "", $0)
            gsub(/".*/, "", $0)
            description = $0
          }
          /^}/ && output_name {
            printf "| %s | %s |\n", output_name, description
            output_name = ""
          }
          ' outputs.tf >> variables.md
        fi
        
        cp variables.md "../../dist/modules/${module_name}-${version}-docs.md"
        
    - name: Upload module artifacts
      uses: actions/upload-artifact@v3
      with:
        name: module-${{ matrix.module }}-${{ steps.version.outputs.new_version }}
        path: dist/modules/
        retention-days: 90
        
    - name: Create git tag
      if: github.ref == 'refs/heads/main'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        tag_name="${{ steps.version.outputs.new_tag }}"
        
        git tag -a "$tag_name" -m "Release ${{ matrix.module }} version ${{ steps.version.outputs.new_version }}"
        git push origin "$tag_name"
        
    - name: Create GitHub release
      if: github.ref == 'refs/heads/main'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          
          const moduleName = '${{ matrix.module }}';
          const version = '${{ steps.version.outputs.new_version }}';
          const tagName = '${{ steps.version.outputs.new_tag }}';
          
          let releaseBody = `## OpenTofu Module: ${moduleName}\n\n`;
          releaseBody += `Version: v${version}\n\n`;
          releaseBody += `### Usage\n\n`;
          releaseBody += '```hcl\n';
          releaseBody += `module "${moduleName}" {\n`;
          releaseBody += `  source = "git::https://github.com/muppet-platform/terraform-modules.git//${moduleName}?ref=${tagName}"\n`;
          releaseBody += `  \n`;
          releaseBody += `  # Add your variables here\n`;
          releaseBody += `}\n`;
          releaseBody += '```\n\n';
          releaseBody += `### Changes\n\n`;
          releaseBody += `See commit history for detailed changes.\n`;
          
          await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: tagName,
            name: `${moduleName} v${version}`,
            body: releaseBody,
            draft: false,
            prerelease: false
          });

  test-published-modules:
    name: Test Published Modules
    runs-on: ubuntu-latest
    needs: [publish-modules]
    if: success()
    
    services:
      localstack:
        image: localstack/localstack:3.0
        ports:
          - 4566:4566
        env:
          SERVICES: s3,ecs,logs,ssm,ecr,elbv2,ec2,iam
          DEBUG: 1
          DATA_DIR: /tmp/localstack/data
          DOCKER_HOST: unix:///var/run/docker.sock
        volumes:
          - /var/run/docker.sock:/var/run/docker.sock
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup OpenTofu
      uses: opentofu/setup-opentofu@v1
      with:
        tofu_version: ${{ env.TOFU_VERSION }}
        
    - name: Wait for LocalStack
      run: |
        timeout 60 bash -c 'until curl -s http://localhost:4566/_localstack/health | grep -q "running"; do sleep 2; done'
        
    - name: Test module integration
      env:
        AWS_ENDPOINT_URL: http://localhost:4566
        AWS_ACCESS_KEY_ID: test
        AWS_SECRET_ACCESS_KEY: test
        AWS_DEFAULT_REGION: us-east-1
      run: |
        mkdir -p integration-test
        cd integration-test
        
        # Create integration test using published modules
        cat > main.tf << EOF
        terraform {
          required_providers {
            aws = {
              source  = "hashicorp/aws"
              version = "~> 5.0"
            }
          }
        }
        
        provider "aws" {
          region                      = "us-east-1"
          access_key                  = "test"
          secret_key                  = "test"
          skip_credentials_validation = true
          skip_metadata_api_check     = true
          skip_requesting_account_id  = true
          
          endpoints {
            s3       = "http://localhost:4566"
            ecs      = "http://localhost:4566"
            logs     = "http://localhost:4566"
            ssm      = "http://localhost:4566"
            ecr      = "http://localhost:4566"
            elbv2    = "http://localhost:4566"
            ec2      = "http://localhost:4566"
            iam      = "http://localhost:4566"
          }
        }
        
        # Test using modules from git
        module "networking" {
          source = "git::https://github.com/muppet-platform/terraform-modules.git//networking?ref=main"
          
          vpc_name = "integration-test-vpc"
          environment = "test"
        }
        
        module "ecr" {
          source = "git::https://github.com/muppet-platform/terraform-modules.git//ecr?ref=main"
          
          repository_name = "integration-test-repo"
        }
        EOF
        
        # Initialize and plan
        tofu init
        tofu plan
        
        echo "âœ… Module integration test passed"

  notify-consumers:
    name: Notify Module Consumers
    runs-on: ubuntu-latest
    needs: [test-published-modules]
    if: success()
    
    steps:
    - name: Create module update notification
      run: |
        echo "Module publishing completed successfully."
        echo "Consumers should update their module references to use the latest versions."
        
        # In a real implementation, this might:
        # 1. Update a module registry
        # 2. Send notifications to teams using the modules
        # 3. Create pull requests to update module versions in dependent repositories
        # 4. Update documentation with new module versions